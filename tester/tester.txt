<b>Тестировщик</b>

Самое главное, что нужно узнать об автоматизации тестирования, - это разница между ручными и автоматизированными тестами.

Ручные тесты могут:

- быть зависимыми друг от друга, если так проще (например, один тест создает данные для следующего теста)

- падать, но тестировщик может легко описать результаты. Также тестировщик может продолжить прохождение следующего теста, даже если первый тест оставил систему в недействительном состоянии.

- занимать разное время для выполнения определенных действий, но тестировщик знает, когда ждать и когда продолжать

- выполняться в определенные даты (тестеры могут установить и сбросить дату, если это необходимо)

Автоматизированные тесты должны:

- быть записаны как

/independent_test_cases - <b>Независимые тесты</b> - чтобы их не приходилось выполнять вместе каждый раз. См. также

/prioritized_tests - <b>Приоритетные тесты</b>
/fresh_setup - <b>Свежая настройка</b>
/test_selector - <b>Выбор тестов</b>

- /fail_gracefully - <b>Изящный провал</b> - чтобы следующие тесты могли выполняться в обычном режиме

- иметь /one_clear_purpose - <b>Одна ясная цель</b> - чтобы облегчить проверку результатов. См. также

/readable_reports - <b>Читаемые отчеты</b>
/comparison_design - <b>Дизайн сравнения</b>
/expected_fail_status - <b>Ожидаемый статус падения</b>

- использовать данные повторно когда это возможно

/default_data - <b>Данные по умолчанию</b>
/testware_architecture - <b>Архитектура тестового ПО</b>

- использовать /variable_delays - <b>Переменные задержки</b> - чтобы дождаться завершения некоторых действий в тестируемой системе (SUT), вместо того, чтобы немедленно двигаться дальше и, следовательно, терять синхронизацию

- уметь выполнять тесты с учетом даты

/date_independence - <b>Независимость от даты</b>

- быть написанным с минимально возможной зависимостью от инструмента тестирования. Шаблоны, которые нужно искать в этом случае, - это

/tool_independence - <b>Независимость от интструмента</b> и /object_map - <b>Карта объекта</b>

- быть поддерживаемым. Например, написание модульных сценариев. Это означает, что действия, выполняемые во многих тестовых случаях, записываются каждый в определенном сценарии, который может быть вызван при необходимости. Таким образом, изменения влияют только на один сценарий, а не на все тестовое ПО. См. также

/good_programming_practices - <b>Хорошие практики программирования</b>

/keyword_driven_testing - <b>Тестирование на основе ключевых слов</b>

/single_page_scripts - <b>Одностраничные сценарии</b>

Другими важными шаблонами являются

/maintainable_testware - <b>Поддерживаемое тестовое обеспечение.</b>

/design_for_reuse - <b>Проектирование для переиспользования</b>

/abstraction_levels - <b>Уровни абстракции</b>

